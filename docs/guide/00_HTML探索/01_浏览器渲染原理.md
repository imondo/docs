# 浏览器渲染原理

## HTML 文件转换为 DOM 树

打开网页的时候，浏览器会请求对应的 HTML 文件。其实就是由字符串组成的一个文件，但是计算机硬件是不理解这些字符串的，所以在网络传输的内容其实是 0 和 1 这些字节数据。当浏览器介绍到这些字节数据后，它将这些字节数据转换成字符串，也就是我们写的代码。

```bash
字节数据 => 字符串（代码）
```

当数据转换成字符串后，浏览器会将这些字符串通过词法分析转换为标记(token)，这一过程在词法分析中叫标记化(tokennization)

```bash
字节数据 => 字符串 => Token
```

标记还是字符串，是构成代码的最小单位。这一过程将代码分拆为一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。

![标记](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ea575740a2f4d0a9400779d56a70182~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树

![DOM 树](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af1ec0497504475287d7a11f988a9496~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

整个转换过程

```bash
字节数据 => 字符串 => Token => Node => DOM
```

## CSS 文件转换为 CSSOM 树

转换 CSS 到 CSSOM 树的过程和 HTML 类似

```bash
字节数据 => 字符串 => Token => Node => CSSOM
```

这一过程，浏览器确认每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式可以自行设置给某个节点，也可以通过继承获得。这一个过程，浏览器递归 CSSOM 树，然后确定元素到底是什么样式。

为什么会消耗资源？

```html
<div>
  <a> <span></span> </a>
</div>
<style>
  span {
    color: red;
  }
  div > a > span {
    color: red;
  }
</style>
```

对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 `span` 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 `span` 标签，然后找到 `span` 标签上的 `a` 标签，最后再去找到 `div` 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写**过于具体**的 `CSS` 选择器，然后对于 `HTML` 来说也尽量少的添加无意义标签，保证**层级扁平**。

## 生产渲染树

 DOM 树 + CSSOM 树 => 渲染树。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a71c46b79d364655ba35b9b87f6d133b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这一过程，不是简单的两者合并。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 `display: none` 的，那么就不会在渲染树中显示。

当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做**回流**），然后调用 GPU 绘制，合成图层，显示在屏幕上。

整个步骤：

- 加载整体 `HTML` 文件

- 至上而下解析 `HTML`

- 解析 `HTML` 建立 `DOM` 树，遇到诸如`<script>`、`<link>`等标签时，就会去下载相应内容，并解析、执行。

- 如果是 `<link>` 标签，解析 `CSS` 构建 `CSSOM` 树

- `DOM` 和 `CSSOM` 结合生成 `render` 树

- 布局 `render` 树（Layout/reflow），负责各元素尺寸、位置的计算

- 绘制 `render` 树（paint），绘制页面像素信息

- 浏览器会将各层的信息发送给 `GPU`，`GPU` 会将各层合成（composite），显示在屏幕上。

![repaint-reflow-2.png](/imgs/repaint-reflow-2.png)

## 重排和重绘

当浏览器打开任何一个页面，在页面首次渲染时，后面会伴随着一系列操作，如 JavaScript 脚本动态操作 DOM 或 CSSOM，用户的输入，异步加载，动效，用户滚动页面，用户调整浏览器视窗大小等，都会在首次渲染的基础上进行更新。

所以，页面首次都会进行一次绘制。在这以后，对构建渲染树信息进行任何改变都会造成两种结果：

- 渲染树的部分（全部）内容需要重新验证，并重新计算节点尺寸。这个过程就是**重排**或者**回流**、**布局**

- 页面部分内容需要获取更新，如节点(Node)的几何信息变化，或者一些类似背景颜色之类的 CSS 样式上的变化。这个过程就是 **重绘**

页面的初始布局至少会重排一次；重绘不一定导致重排，但重排一定会导致重绘。

- 重排（reflow）：DOM 布局发生改变，引起重排（改变窗口大小，字体大小...）

- 重绘（repaint）：元素的 CSS 属性发生改变，引起重绘（color，border-style，background...）

引起重排的操作有：

1. 页面首次渲染。
2. 浏览器窗口大小发生改变。
3. 元素尺寸或位置发生改变。
4. 元素内容变化（文字数量或图片大小等等）。
5. 元素字体大小变化。
6. 添加或者删除可见的 `DOM` 元素。
7. 激活 `CSS` 伪类（例如：:hover）。
8. 设置 `style` 属性
9. 查询某些属性或调用某些方法。

常见引起重排属性和方法

`width`, `height`, `border` ...

## 操作 DOM 慢

操作 DOM 性能很差，但是其中是什么原因？

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的事物，当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。

> 插入几万个 DOM，如何实现页面不卡顿？

