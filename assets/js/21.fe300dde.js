(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{237:function(e,t,n){"use strict";n.r(t);var s=n(0),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"vue使用过程小记（持续更新）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue使用过程小记（持续更新）"}},[e._v("#")]),e._v(" Vue使用过程小记（持续更新）")]),e._v(" "),n("h2",{attrs:{id:"指令"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#指令"}},[e._v("#")]),e._v(" 指令")]),e._v(" "),n("ul",[n("li",[e._v("v-bind可以绑定对象")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('\x3c!-- 绑定一个有属性的对象 --\x3e\n<div v-bind="{ id: someProp, \'other-attr\': otherProp }"></div>\n\n\x3c!-- 通过 prop 修饰符绑定 DOM 属性 --\x3e\n<div v-bind:text-content.prop="text"></div>\n\n\x3c!-- prop 绑定。“prop”必须在 my-component 中声明。--\x3e\n<my-component :prop="someThing"></my-component>\n\n\x3c!-- 通过 $props 将父组件的 props 一起传给子组件 --\x3e\n<child-component v-bind="$props"></child-component>\n\n\x3c!-- XLink --\x3e\n<svg><a :xlink:special="foo"></a></svg>\n')])])]),n("h2",{attrs:{id:"利用函数来传递数据有奇效"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#利用函数来传递数据有奇效"}},[e._v("#")]),e._v(" 利用函数来传递数据有奇效")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 表格是否可以勾选判断条件\nselectable: {\n  type: Function,\n  default: () => {\n    return true;\n  }\n}\n")])])]),n("h2",{attrs:{id:"vue的dispatch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue的dispatch"}},[e._v("#")]),e._v(" vue的dispatch")]),e._v(" "),n("ul",[n("li",[e._v("同级的"),n("code",[e._v("actions")]),e._v("可以引入"),n("code",[e._v("dispatch")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("GenerateRoutes({ dispatch, commit }, data) {\n  ...\n}\n")])])]),n("ul",[n("li",[n("code",[e._v("dispatch")]),e._v("最多就只接受两个参数，"),n("code",[e._v("type")]),e._v("和"),n("code",[e._v("payload")])])]),e._v(" "),n("p",[e._v("传递第三个，为"),n("code",[e._v("undefined")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("dispatch('AddRoutesIndex', {\n  routes: accessedRouters,\n  index: schoolRouterIndex\n});\n")])])]),n("h2",{attrs:{id:"elementui中el-tabs组件中el-table的宽度问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#elementui中el-tabs组件中el-table的宽度问题"}},[e._v("#")]),e._v(" ElementUI中el-tabs组件中el-table的宽度问题")]),e._v(" "),n("p",[e._v("在tabs使用table会出现滚动条遮住内容可以使用"),n("code",[e._v("v-if")]),e._v("控制"),n("code",[e._v("el-tab-pane")]),e._v("里的内容\n例如"),n("code",[e._v("v-if=\"activeName === 'second'\"")])]),e._v(" "),n("h2",{attrs:{id:"通过跨域方式获取信息"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#通过跨域方式获取信息"}},[e._v("#")]),e._v(" 通过跨域方式获取信息")]),e._v(" "),n("p",[e._v("项目"),n("code",[e._v("token.html")]),e._v("引入"),n("a",{attrs:{href:"https://github.com/zendesk/cross-storage",target:"_blank",rel:"noopener noreferrer"}},[e._v("cross-storage"),n("OutboundLink")],1),e._v("可以跨域获取信息")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// utils/auth.js\n\nvar iportal = new CrossStorageClient(\'token.html\');\niportal.onConnect().then(() => iportal.get(accessToken)).then(token_list => {\n  const tokenObj = JSON.parse(token_list); // { "access_token":"4bd53dcc-2e94-4652-9463-d4495c2509ad", "token_type":"bearer", ... }\n  resolve(tokenObj);\n});\n')])])]),n("h2",{attrs:{id:"refreshtoken获取方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#refreshtoken获取方案"}},[e._v("#")]),e._v(" RefreshToken获取方案")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// /config/fetch.js\n...\nlet isRefreshing = false; // refresh_token是否刷新成功\nlet queueRequests = []; // refresh_token刷新并行接口集合队列\nswitch (status) {\n  case 401:\n    const { config } = error.response;\n    if (!isRefreshing) {\n      isRefreshing = true;\n      const refreshToken = RefreshToken.getInstance(store.state.config.webIportalURL);\n      return refreshToken.init().then(token => {\n        if (token && token.refresh_token && token.isPastDue) {\n          config.headers.Authorization = token.token_type + ' ' + token.access_token;\n          config.url = config.url.substr(config.url.indexOf('api/') + 4);\n          queueRequests.forEach((cb) => cb(token))\n          // 重试完清空这个队列\n          queueRequests = []\n          return axios(config);\n        } else {\n          ...\n        }\n      }).finally(() => {\n        isRefreshing = false\n      });\n    } else {\n      return new Promise((resolve) => {\n        // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行\n        queueRequests.push((token) => {\n          config.headers.Authorization = token.token_type + ' ' + token.access_token;\n          config.url = config.url.substr(config.url.indexOf('api/') + 4);\n          resolve(axios(config));\n        })\n      })\n    }      \n    break;\n  case 403:\n        ...\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);