import{_ as s,c as a,o as n,a as p}from"./app.1805c7d6.js";const D=JSON.parse('{"title":"函数式编程","description":"","frontmatter":{},"headers":[],"relativePath":"guide/02_JS探索/013_函数式编程.md","lastUpdated":1675155362000}'),l={name:"guide/02_JS探索/013_函数式编程.md"},o=p(`<h1 id="函数式编程" tabindex="-1">函数式编程 <a class="header-anchor" href="#函数式编程" aria-hidden="true">#</a></h1><p>纯函数是函数式编程的一个最大的前提。</p><ul><li><p>纯函数、副作用的内涵</p></li><li><p>纯函数、非纯函数的解析</p></li><li><p>从数据流的角度理解“纯”和“不纯”的本质</p></li><li><p>纯函数解决了什么问题</p></li></ul><h2 id="两个概念" tabindex="-1">两个概念 <a class="header-anchor" href="#两个概念" aria-hidden="true">#</a></h2><h3 id="什么是纯函数" tabindex="-1">什么是纯函数？ <a class="header-anchor" href="#什么是纯函数" aria-hidden="true">#</a></h3><p>同时满足两个条件：</p><ul><li><p>对于相同的输入，总是得到相同的输出</p></li><li><p>在执行过程中没有语义上可观察的副作用</p></li></ul><h3 id="什么是副作用" tabindex="-1">什么是副作用？ <a class="header-anchor" href="#什么是副作用" aria-hidden="true">#</a></h3><p>生活上的药物副作用，我们为了治疗A疾病服用某种药物，药物在缓解A疾病的症状之余，可能会导致B疾病。那么“引发B疾病”就是这个药物的副作用。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在计算机科学中，<strong>函数副作用</strong>指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。 ——维基百科</p></div><p>如果一个函数除了计算之外，还对它的执行上下文、执行宿主等外部环境造成了一些其它的影响，那么这些影响就是所谓的”副作用”。</p><p>举个例子：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">20</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;">b</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>这个函数不是纯函数。对于相同的输入，无法做到相同的输出。初次执行 <code>add()</code> 时，会 <code>return</code> 一个 <code>30</code> 出来，但是在全局作用域下修改：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">30</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">40</span></span>
<span class="line"></span></code></pre></div><p>此时再次调用 <code>add()</code>，我们得到的输出就将从 <code>30</code> 变为 <code>70</code>。</p><p>对于相同的输入，<code>add()</code> 函数给到了不同的输出。这违背了纯函数的第一条规则：对于相同的输入，总是会得到相同的输出。</p><p>这里要强调的是：“输入”指的是<strong>函数的入参</strong>。</p><p>那么如何编程一个纯函数呢？只需要把“数据的输入”交给入参来做就可以了</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">20</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">b</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;">b</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 30</span></span>
<span class="line"><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> b)   </span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">30</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">40</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 70</span></span>
<span class="line"><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> b)</span></span>
<span class="line"></span></code></pre></div><p>简单的改造后，<code>add</code> 函数就能够充分满足纯函数的两个条件了：</p><ul><li><p>对于相同的输入，总是会得到相同的输出：对于相同的 <code>a</code> 和 <code>b</code> 来说，它们的和总是相等的✅</p></li><li><p>在执行过程中没有语义上可观察的副作用：<code>add()</code> 函数除了加法计算之外没有做任何事，不会对外部世界造成额外影响✅</p></li></ul><h3 id="纯和不纯的本质" tabindex="-1">纯和不纯的本质 <a class="header-anchor" href="#纯和不纯的本质" aria-hidden="true">#</a></h3><p>“纯”的本质——有且仅有【显式数据流】。</p><p>显式概念，约束的是数据的来源（<strong>入参</strong>）和出口（<strong>返回值</strong>）。说明数据只能以入参的形式进来，并且只能以返回值的形式出去。</p><p>纯函数 ———— 输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，不以任何其它形式和外界进行数据交换的函数。</p><p>纯函数的计算<strong>完全发生在函数的内部</strong>，它不会对外部资源产生任何影响，因此纯函数的并行计算总是安全的。</p><p>纯函数是高度灵活的函数，它的计算逻辑在任何上下文里都是成立的。</p><p>设计模式中，我们强调将“变与不变”分离，而纯函数强调将计算与副作用分离。</p><p>纯函数并不是为了约束而约束，而是为了追求更高的确定性；同时引导我们做更加合理的逻辑分层，写出更加清晰、更善于应对变化的代码。</p><h2 id="一等公民" tabindex="-1">一等公民 <a class="header-anchor" href="#一等公民" aria-hidden="true">#</a></h2><p>头等函数的核心特征是<strong>可以被当做变量一样用</strong></p><ul><li><p>可以被当作参数传递给其他函数</p></li><li><p>可以作为另一个函数的返回值</p></li><li><p>可以被赋值给一个变量</p></li></ul><p>JS 函数的本质，就是<strong>可执行的对象</strong>。</p><h2 id="确保数据的不可变性" tabindex="-1">确保数据的不可变性 <a class="header-anchor" href="#确保数据的不可变性" aria-hidden="true">#</a></h2><p>“不可变”不是要消灭变化，而是要控制变化。控制变化，确保所有的变化都在可预期的范围内发生，从而防止我们的程序被变化“偷袭”。</p><p>数据不可变性如何在前端业务中落地？</p>`,37),e=[o];function t(c,r,i,d,C,y){return n(),a("div",null,e)}const F=s(l,[["render",t]]);export{D as __pageData,F as default};
