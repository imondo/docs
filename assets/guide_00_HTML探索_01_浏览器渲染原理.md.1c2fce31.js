import{_ as s,c as o,o as a,a as p}from"./app.62276965.js";const l="/docs/imgs/repaint-reflow-2.png",n="/docs/imgs/defer.png",g=JSON.parse('{"title":"浏览器渲染原理","description":"","frontmatter":{},"headers":[],"relativePath":"guide/00_HTML探索/01_浏览器渲染原理.md","lastUpdated":1670837715000}'),e={name:"guide/00_HTML探索/01_浏览器渲染原理.md"},c=p(`<h1 id="浏览器渲染原理" tabindex="-1">浏览器渲染原理 <a class="header-anchor" href="#浏览器渲染原理" aria-hidden="true">#</a></h1><h2 id="html-文件转换为-dom-树" tabindex="-1">HTML 文件转换为 DOM 树 <a class="header-anchor" href="#html-文件转换为-dom-树" aria-hidden="true">#</a></h2><p>打开网页的时候，浏览器会请求对应的 HTML 文件。其实就是由字符串组成的一个文件，但是计算机硬件是不理解这些字符串的，所以在网络传输的内容其实是 0 和 1 这些字节数据。当浏览器介绍到这些字节数据后，它将这些字节数据转换成字符串，也就是我们写的代码。</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">字节数据 =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> 字符串（代码）</span></span>
<span class="line"></span></code></pre></div><p>当数据转换成字符串后，浏览器会将这些字符串通过词法分析转换为标记(token)，这一过程在词法分析中叫标记化(tokennization)</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">字节数据 =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> 字符串 =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> Token</span></span>
<span class="line"></span></code></pre></div><p>标记还是字符串，是构成代码的最小单位。这一过程将代码分拆为一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ea575740a2f4d0a9400779d56a70182~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="标记"></p><p>当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af1ec0497504475287d7a11f988a9496~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="DOM 树"></p><p>整个转换过程</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">字节数据 =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> 字符串 =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> Token =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> Node =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> DOM</span></span>
<span class="line"></span></code></pre></div><h2 id="css-文件转换为-cssom-树" tabindex="-1">CSS 文件转换为 CSSOM 树 <a class="header-anchor" href="#css-文件转换为-cssom-树" aria-hidden="true">#</a></h2><p>转换 CSS 到 CSSOM 树的过程和 HTML 类似</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">字节数据 =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> 字符串 =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> Token =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> Node =</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> CSSOM</span></span>
<span class="line"></span></code></pre></div><p>这一过程，浏览器确认每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式可以自行设置给某个节点，也可以通过继承获得。这一个过程，浏览器递归 CSSOM 树，然后确定元素到底是什么样式。</p><p>为什么会消耗资源？</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">span</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> red</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">a</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">span</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> red</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 <code>span</code> 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 <code>span</code> 标签，然后找到 <code>span</code> 标签上的 <code>a</code> 标签，最后再去找到 <code>div</code> 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写<strong>过于具体</strong>的 <code>CSS</code> 选择器，然后对于 <code>HTML</code> 来说也尽量少的添加无意义标签，保证<strong>层级扁平</strong>。</p><h2 id="生产渲染树" tabindex="-1">生产渲染树 <a class="header-anchor" href="#生产渲染树" aria-hidden="true">#</a></h2><p>DOM 树 + CSSOM 树 =&gt; 渲染树。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a71c46b79d364655ba35b9b87f6d133b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p><p>这一过程，不是简单的两者合并。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</p><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做<strong>回流</strong>），然后调用 GPU 绘制，合成图层，显示在屏幕上。</p><p>整个步骤：</p><ul><li><p>加载整体 <code>HTML</code> 文件</p></li><li><p>至上而下解析 <code>HTML</code></p></li><li><p>解析 <code>HTML</code> 建立 <code>DOM</code> 树，遇到诸如<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code>等标签时，就会去下载相应内容，并解析、执行。</p></li><li><p>如果是 <code>&lt;link&gt;</code> 标签，解析 <code>CSS</code> 构建 <code>CSSOM</code> 树</p></li><li><p><code>DOM</code> 和 <code>CSSOM</code> 结合生成 <code>render</code> 树</p></li><li><p>布局 <code>render</code> 树（Layout/reflow），负责各元素尺寸、位置的计算</p></li><li><p>绘制 <code>render</code> 树（paint），绘制页面像素信息</p></li><li><p>浏览器会将各层的信息发送给 <code>GPU</code>，<code>GPU</code> 会将各层合成（composite），显示在屏幕上。</p></li></ul><p><img src="`+l+`" alt="repaint-reflow-2.png"></p><h2 id="重排和重绘" tabindex="-1">重排和重绘 <a class="header-anchor" href="#重排和重绘" aria-hidden="true">#</a></h2><p>当浏览器打开任何一个页面，在页面首次渲染时，后面会伴随着一系列操作，如 JavaScript 脚本动态操作 DOM 或 CSSOM，用户的输入，异步加载，动效，用户滚动页面，用户调整浏览器视窗大小等，都会在首次渲染的基础上进行更新。</p><p>所以，页面首次都会进行一次绘制。在这以后，对构建渲染树信息进行任何改变都会造成两种结果：</p><ul><li><p>渲染树的部分（全部）内容需要重新验证，并重新计算节点尺寸（布局有变化）。这个过程就是<strong>重排</strong>或者<strong>回流</strong>、<strong>布局</strong></p></li><li><p>页面部分内容需要获取更新，如节点(Node)的几何信息变化，或者一些类似背景颜色之类的 CSS 样式上的变化（样式有变化）。这个过程就是 <strong>重绘</strong></p></li></ul><p>页面的初始布局至少会重排一次；重绘不一定导致重排，但重排一定会导致重绘。</p><ul><li><p>重排（reflow）：DOM 布局发生改变，引起重排（改变窗口大小，字体大小...）</p></li><li><p>重绘（repaint）：元素的 CSS 属性发生改变，引起重绘（color，border-style，background...）</p></li></ul><p>引起重排的操作有：</p><ol><li>页面首次渲染。</li><li>浏览器窗口大小发生改变。</li><li>元素尺寸或位置发生改变。</li><li>元素内容变化（文字数量或图片大小等等）。</li><li>元素字体大小变化。</li><li>添加或者删除可见的 <code>DOM</code> 元素。</li><li>激活 <code>CSS</code> 伪类（例如：:hover）。</li><li>设置 <code>style</code> 属性</li><li>查询某些属性或调用某些方法。</li></ol><p>常见引起重排属性和方法</p><p><code>width</code>, <code>height</code>, <code>border</code> ...</p><h3 id="减少重绘和回流" tabindex="-1">减少重绘和回流 <a class="header-anchor" href="#减少重绘和回流" aria-hidden="true">#</a></h3><ul><li>使用 <code>transform</code> 替代 <code>top</code></li></ul><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">test</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">position</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> absolute</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">top</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10px</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">width</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100px</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">height</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100px</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">background</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> red</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">style</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 引起回流</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">.test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">top</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">100px</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><ul><li><p>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</p></li><li><p>修改频繁的元素先<code> display: none</code>，修改完之后显示</p></li><li><p>不要逐条修改 <code>DOM</code> 样式，尽量提前设置好 <code>class</code>，后续增加 <code>class</code>，进行批量修改</p></li><li><p>使用 <code>documentFragment</code> 对象在内存里操作 <code>DOM</code></p></li><li><p>不要把节点的属性值放在一个循环里当成循环里的变量</p></li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">for</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">.test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">offsetTop</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li><p>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</p></li><li><p>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></p></li><li><p><code>CSS</code> 选择符从右往左匹配查找，避免<strong>节点层级过多</strong></p></li><li><p>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层。</p></li></ul><p>设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层</p><ul><li>will-change</li><li>video、iframe 标签</li></ul><h2 id="操作-dom-慢" tabindex="-1">操作 DOM 慢 <a class="header-anchor" href="#操作-dom-慢" aria-hidden="true">#</a></h2><p>操作 <code>DOM</code> 性能很差，但是其中是什么原因？</p><p>因为 <code>DOM</code> 是属于渲染引擎中的东西，而 <code>JS</code> 又是 <code>JS</code> 引擎中的事物，当我们通过 <code>JS</code> 操作 <code>DOM</code> 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来性能上的损耗。操作 <code>DOM</code> 次数一多，也就等同于一直在进行线程之间的通信，并且操作 <code>DOM</code> 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。</p><blockquote><p>插入几万个 DOM，如何实现页面不卡顿？</p></blockquote><ul><li><p>分批次部分渲染 <code>DOM</code></p></li><li><p><code>requestAnimationFrame</code></p></li><li><p>虚拟滚动（virtualized scroller）：只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容</p></li></ul><h2 id="什么情况阻塞渲染" tabindex="-1">什么情况阻塞渲染 <a class="header-anchor" href="#什么情况阻塞渲染" aria-hidden="true">#</a></h2><p>渲染的前提是生成渲染树；所以 HTML 和 CSS 肯定会阻塞渲染。</p><p>渲染越快，应降低<strong>渲染文件的大小</strong>，并且<strong>避免多层无意义嵌套</strong>，<strong>优化选址器</strong>。</p><p>当浏览器在解析到 <code>script</code> 标签的时，会暂停构建 <code>DOM</code> ，浏览器必须等脚本下载完，并执行结束，如果想首屏渲染越快，就越不应该在首屏加载 <code>JS</code> 文件，这也是建议将 <code>script</code> 标签放在 <code>body</code> 标签底部的原因。</p><p>在现代，并不必须将 <code>script</code> 标签放在底部，因为可以给标签添加 <code>defer</code> 或 <code>async</code> 属性</p><h3 id="defer" tabindex="-1">defer <a class="header-anchor" href="#defer" aria-hidden="true">#</a></h3><p>表示 <code>JS</code> 文件会并行下载，但是会放到 <code>HTML</code> 解析完成后顺序执行</p><p>告诉浏览器不要等待 <code>JS</code> 脚本。相反，浏览器将继续处理 <code>HTML</code>，构建 <code>DOM</code>。脚本会“在后台”下载，然后等 <code>DOM</code> 构建完成后，脚本才会执行</p><p>如果多个 <code>JS</code> 文件都存在 <code>defer</code> 属性时：</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">defer</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">a.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">defer</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">b.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>它们会并行下载；但是，<code>defer</code> 除了告诉浏览器“不要阻塞页面”之外，还会保持 <code>JS</code> 执行的相对顺序，因此，即使<code> b.js</code> 先加载完成，它人需要等到 <code>a.js</code> 执行结束才会被执行。</p><div class="tip custom-block"><p class="custom-block-title">提示</p><p><code>defer</code> 特性仅适用于外部脚本</p><p>如果 <code>&lt;script&gt;</code> 脚本没有 <code>src</code>，则会忽略 <code>defer</code> 特性。</p></div><h3 id="async" tabindex="-1">async <a class="header-anchor" href="#async" aria-hidden="true">#</a></h3><p>表示 <code>JS</code> 文件下载不会阻塞渲染（解析应该是会阻塞渲染的）</p><p><code>JS</code> 是完全独立的</p><ul><li><p>浏览器不会因 <code>async</code> 脚本而阻塞</p></li><li><p>其他 <code>JS</code> 不会等待 <code>async</code> 脚本加载完成，同样， <code>async</code> 脚本也不会等待其他 <code>JS</code></p></li><li><p>同时具有 <code>async</code> 属性的 <code>JS</code>，谁先加载谁执行，不保证顺序加载</p></li></ul><p>当我们将独立的第三方脚本集成到页面时，此时采用异步加载方式是非常棒的：<strong>计数器</strong>，<strong>广告</strong>等，因为它们不依赖于我们的脚本，我们的脚本也不应该等待它们</p><div class="tip custom-block"><p class="custom-block-title">提示</p><p><code>async</code> 特性仅适用于外部脚本</p><p>如果 <code>&lt;script&gt;</code> 脚本没有 <code>src</code>，则会忽略 <code>async</code> 特性。</p></div><p><img src="`+n+'" alt="defer.png"></p><blockquote><p>在不考虑缓存和优化网络协议的前提下，考虑可以通过哪些方式来最快的渲染页面</p></blockquote><p>当发生 <code>DOMContentLoaded</code> 事件后，就会生成渲染树，生成渲染树就可以进行渲染了，这一过程更大程度上和硬件有关系了。</p><p>如何加速：</p><ul><li><p>文件大小</p></li><li><p><code>script</code> 标签使用</p></li><li><p><code>HTML</code>、<code>CSS</code> 代码书写格式</p></li><li><p>首屏是否需要的文件</p></li></ul><p>一些建议：</p><ul><li><p>减少文件大小，尽量压缩</p></li><li><p><code>script</code> 标签异步加载</p></li><li><p>CSS 不要写多层级选择器，HTML 减少无意义标签，扁平化，避免多层无意义嵌套</p></li><li><p>首页内容尽量优化，减少不必要加载或延后加载</p></li><li><p>对首页布局样式无影响的 JS 延后加载</p></li></ul>',75),t=[c];function r(d,i,D,y,F,C){return a(),o("div",null,t)}const h=s(e,[["render",r]]);export{g as __pageData,h as default};
