import{_ as s,c as l,o as a,a as n}from"./app.72bf9abe.js";const p="/docs/imgs/stack.gif",o="/docs/imgs/stack.png",u=JSON.parse('{"title":"线程机制与事件循环","description":"","frontmatter":{"sidebar_position":9},"headers":[],"relativePath":"guide/02_JS探索/09_JavaScript线程机制.md","lastUpdated":1671534361000}'),e={name:"guide/02_JS探索/09_JavaScript线程机制.md"},c=n(`<h1 id="线程机制与事件循环" tabindex="-1">线程机制与事件循环 <a class="header-anchor" href="#线程机制与事件循环" aria-hidden="true">#</a></h1><h2 id="线程与进程" tabindex="-1">线程与进程 <a class="header-anchor" href="#线程与进程" aria-hidden="true">#</a></h2><p>进程描述了 <strong>CPU 在运行指令及加载和保存上下文所需的时间</strong>，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。</p><p>把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><p>一些概念：</p><ul><li><p>多线程：指的是这个程序（一个进程）运行时产生了不止一个线程</p></li><li><p>并行与并发：</p><ul><li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li><li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。</li><li>并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，</li><li>我们会用TPS或者QPS来反应这个系统的处理能力。</li></ul></li><li><p>进程</p><ul><li>程序的一次执行，它占有一片独有的内存空间</li><li>可以通过 <code>window</code> 任务管理器查看进程</li></ul></li><li><p>线程</p><ul><li>是进程内的一个独立执行单元</li><li>是程序执行的一个完整流程</li><li>是CPU的最小的调度单元</li></ul></li><li><p>关系</p><ul><li>一个进程至少有一个线程（主）</li><li>程序是在某个进程中的某个线程执行的</li></ul></li></ul><h2 id="执行栈" tabindex="-1">执行栈 <a class="header-anchor" href="#执行栈" aria-hidden="true">#</a></h2><p>执行栈就是存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">a</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">b</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">a</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">b</span><span style="color:#A6ACCD;">())</span></span>
<span class="line"></span></code></pre></div><p>看到上面的代码，在调试阶段可以看到执行栈的执行顺序。首先执行全局代码，根据先进后出的原则，后执行的函数 <code>a</code> 会先弹出栈。</p><p><img src="`+p+`" alt=""></p><p>或者在一些报错信息中，也可以找到执行栈的痕迹</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">a</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">throw</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Error</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">error</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">b</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">a</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">b</span><span style="color:#A6ACCD;">())</span></span>
<span class="line"></span></code></pre></div><p><img src="`+o+`" alt=""></p><p>我们可以在上图中看到报错在 <code>a</code> 函数，<code>a</code> 函数又是在 <code>b</code> 函数中调用的。</p><p>当我们使用递归的时候，因为执行栈的内存空间是有限的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题。</p><h2 id="浏览器内核模块" tabindex="-1">浏览器内核模块 <a class="header-anchor" href="#浏览器内核模块" aria-hidden="true">#</a></h2><ul><li>主线程 <ul><li><code>js</code> 引擎模块：负责js程序的编译与运行</li><li>html,css文档解析模块：负责页面文本的解析</li><li>DOM/CSS模块：负责dom/css在内存中的相关处理</li><li>布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）</li></ul></li><li>分线程 <ul><li>定时器模块：负责定时器的管理</li><li>DOM事件响应模块：负责事件的管理</li><li>网络请求模块：负责Ajax请求</li></ul></li></ul><h2 id="js线程" tabindex="-1">js线程 <a class="header-anchor" href="#js线程" aria-hidden="true">#</a></h2><ul><li>js是单线程执行的（回调函数在主线程）</li><li>h5提出了实现多线程的方案：Web Workers</li><li>只能是主线程更新界面</li></ul><h2 id="定时器问题" tabindex="-1">定时器问题 <a class="header-anchor" href="#定时器问题" aria-hidden="true">#</a></h2><ul><li>定时器并不是完全定时</li><li>如果在主线程执行了一个长时间的操作，可能导致延时才处理</li></ul><h2 id="任务" tabindex="-1">任务 <a class="header-anchor" href="#任务" aria-hidden="true">#</a></h2><p>我们都知道JS的单线程，就是说只能从上往下，只能执行一个任务；其他的任务要执行都必须在后面排队。</p><ul><li><p>同步任务：那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p></li><li><p>异步任务：那些被引擎放在一边，不进入主线程、而进入任务队列的任务。</p></li></ul><p>常见的用的多的一些异步任务</p><ul><li>ajax 请求</li><li>settimeout</li><li>setinterver</li><li>事件</li><li>promise</li></ul><p>而异步任务里又分了 宏任务，微任务</p><ul><li>同步任务优先执行</li><li>微任务优先宏任务执行</li><li>微任务 <code>promise</code></li><li>宏任务 <code>setTimeout</code></li></ul><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p><p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p><p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？</p><p>答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做<strong>事件循环</strong>（Event Loop）。<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noreferrer">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p><h2 id="事件处理机制" tabindex="-1">事件处理机制 <a class="header-anchor" href="#事件处理机制" aria-hidden="true">#</a></h2><ul><li>代码分类 <ul><li>初始化执行代码：包含绑定dom事件监听，设置定时器，发送 <code>ajax</code> 请求的代码</li><li>回调执行代码：处理回调逻辑</li></ul></li><li>js引擎执行代码的基本流程 <ul><li>初始话代码 ==&gt; 回调代码</li><li>先执行初始化代码：包含一些特别的代码回调函数（异步执行） <ul><li>设置定时器</li><li>绑定事件监听</li><li>发送 <code>ajax</code> 请求</li></ul></li><li>后面在某个时刻才会执行回调代码</li></ul></li><li>模块的2个重要组成部分 <ul><li>事件管理模块</li><li>回调队列</li></ul></li><li>模块的运转流程 <ul><li>执行初始化代码，将事件回调函数交给对应的模块管理</li><li>当事件发生时，管理模块会将回调函数及其数据添加到回调队列中</li><li>只有当初始化代码执行完后（可能要一定时间），才会遍历读取回调队列中的回调函数执行</li></ul></li></ul><h2 id="web-workers" tabindex="-1">Web Workers <a class="header-anchor" href="#web-workers" aria-hidden="true">#</a></h2><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// 可以让js在分线程执行</span></span>
<span class="line"><span style="color:#676E95;">// main.js</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> worker </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Worker</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">worker.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">worker</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onMessage</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;">) </span><span style="color:#676E95;">// 主线程接收分线程发送过来的数据</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">worker</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">postMessage</span><span style="color:#A6ACCD;">(data) </span><span style="color:#676E95;">// 向分线程发送数据</span></span>
<span class="line"><span style="color:#676E95;">// worker.js</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> onmessage </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;">) </span><span style="color:#676E95;">// 接口主线程发送数据</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 向主线程发送数据</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">postMessage</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">reslut</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>缺点</p></blockquote><ul><li><code>worker</code> 内代码不能操作 <code>DOM</code> 更新视图</li><li>浏览器兼容问题</li><li>不能跨域加载 <code>Js</code></li></ul>`,40),r=[c];function t(i,y,F,A,D,d){return a(),l("div",null,r)}const h=s(e,[["render",t]]);export{u as __pageData,h as default};
