import{_ as s,c as a,o as n,a as o}from"./app.3f44cf72.js";const l="/docs/imgs/mvc.png",p="/docs/imgs/mvvm.png",h=JSON.parse('{"title":"框架与框架","description":"","frontmatter":{},"headers":[],"relativePath":"guide/04_FRONTEND/05_框架与框架.md","lastUpdated":1676614967000}'),e={name:"guide/04_FRONTEND/05_框架与框架.md"},c=o('<h1 id="框架与框架" tabindex="-1">框架与框架 <a class="header-anchor" href="#框架与框架" aria-hidden="true">#</a></h1><h2 id="mvvm" tabindex="-1">MVVM <a class="header-anchor" href="#mvvm" aria-hidden="true">#</a></h2><ul><li><p>View：用户视图</p></li><li><p>Model：数据</p></li></ul><p>传统的 <code>MVC</code> 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新</p><p><img src="'+l+'" alt="mvc"></p><p>但是 <code>MVC</code> 有一个巨大的缺陷，<strong>控制器承担的责任太大</strong>。随着项目愈加的复杂，控制器中的代码也会越臃肿，导致不利于维护。</p><p>所以引入 <code>MVVM</code> 模式。添加了 <code>ViewModel</code> 概念。 <code>ViewModel</code> 只关心数据和业务的处理，不关心 <code>View</code> 如何处理数据，在这种情况下， <code>View</code> 和 <code>Model</code> 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可以复用的逻辑放在一个 <code>ViewModel</code> 中，让多个 <code>View</code> 复用这个 <code>ViewModel。</code></p><p><img src="'+p+`" alt="mvvm"></p><p>以 <code>Vue</code> 来举例，<code>ViewModel</code> 就是组件的实例。<code>View</code> 就是模板，<code>Model</code> 引入 <code>Vuex</code> 的情况下完全可以和组件分离。</p><p>对于 <code>MVVM</code> 来说，其实最重要的并不是通过双向绑定或者其他的方式将 <code>View</code> 与<code> ViewModel</code> 绑定起来，而是通过 <code>ViewModel</code> 将视图中的状态和用户的行为分离出一个抽象，这才是 <code>MVVM</code> 的精髓。</p><h2 id="virtual-dom" tabindex="-1">Virtual DOM <a class="header-anchor" href="#virtual-dom" aria-hidden="true">#</a></h2><p>由于直接操作 DOM 会存在性能缺陷，操作 JS 对象会快很多，所以通过 JS 来模拟 DOM</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ul </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">tag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ul</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">props</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">class</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">list</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">tag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">li</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>对应真实的 DOM 结构</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">list</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>可以通过 JS 对象渲染出对应的 DOM，但是如何判断新旧两个 JS 对象的<strong>最小差异</strong>且实现<strong>局部更新</strong> DOM。</p><p>DOM 是一个多叉树结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 <code>O(n ^ 3)</code>，这个复杂度肯定是不能接受的。于是 React 优化了算法，实现 <code>O(n)</code> 的复杂度来对比差异。实现 <code>O(n)</code> 复杂度的关键就是<strong>只对比同层的节点</strong>，而不是跨层对比</p><ul><li><p>先上至下，坐到右遍历对象，树的深度遍历，给每个节点索引，便于最后渲染差异</p></li><li><p>一旦节点有子元素，就去判断子元素是否有不同</p></li></ul><p>第一步中判断新旧节点 <code>tagName</code> 是否相同，如果不相同就代表节点被替换；如果没有更改，就要判断是否有子元素，存在即进行第二步计算。</p><p>在第二步中，需要判断原本的列表中是否有节点被移除，在新的列表中要判断是否有新的节点加入，还需要判断节点是否移动。</p><p>例如：页面中有一个列表，对列表中元素进行了变更</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 假设这里模拟一个 ul，其中包含了 5 个 li</span></span>
<span class="line"><span style="color:#A6ACCD;">[</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 这里替换上面的 li</span></span>
<span class="line"><span style="color:#A6ACCD;">[</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"></span></code></pre></div><p>可以看到 <code>ul</code> 中的第三个 <code>li</code> 被移除，四和五替换了位置。</p><p>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？</p><p>这就引入了 <code>key</code> 属性，大家在列表中都使用过这个属性。这个属性是用来给每一个节点<strong>打标记</strong>的，用于判断是否是同一个节点，节点的属性是否存在变化。</p><p>差异被判断，记录差异，当对比完两颗树后，就可以通过差异去局部更新 <code>DOM</code>，实现性能的最优化。</p><p><code>Virtual DOM</code> 的最大优势：</p><ul><li><p>兼容，实现跨端开发；渲染到其他平台</p></li><li><p>组件高度抽象</p></li></ul><p>也不是万能的。直接操作 <code>DOM</code> 没有 <code>diff</code> 算法损耗。</p><h2 id="前端路由是如何跳转的" tabindex="-1">前端路由是如何跳转的 <a class="header-anchor" href="#前端路由是如何跳转的" aria-hidden="true">#</a></h2><p>前端路由本质是<strong>监听 URL 的变化</strong>，匹配路由规则，显示相应的页面，无需刷新页面。两种路由实现方式：</p><ul><li><p><code>Hash</code> 模式</p></li><li><p><code>History</code> 模式</p></li></ul><h3 id="hash-模式" tabindex="-1">Hash 模式 <a class="header-anchor" href="#hash-模式" aria-hidden="true">#</a></h3><p><code>test.com/#/</code> 就是 <code>Hash URL</code>，当 <code>#</code> 后面的哈希值发生变化后，可以使用 <code>hashchange</code> 事件监听 URL 的变化，进行页面跳转，无论哈希值如何变化，服务端收到的 URL 请求一直是 <code>test.com</code>。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hashchange</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// code</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p><code>Hash</code> 模式兼容性更好。</p><h3 id="history-模式" tabindex="-1">History 模式 <a class="header-anchor" href="#history-模式" aria-hidden="true">#</a></h3><p>History 模式是 HTML5 功能，主要使用 <code>history.pushState</code> 和 <code>history.replaceState</code> 监听 <code>URL</code> 变化。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 新增历史记录</span></span>
<span class="line"><span style="color:#A6ACCD;">history</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pushState</span><span style="color:#A6ACCD;">(stateObject</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> title</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> URL)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 替换当前历史记录</span></span>
<span class="line"><span style="color:#A6ACCD;">history</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replaceState</span><span style="color:#A6ACCD;">(stateObject</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> title</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> URL)</span></span>
<span class="line"></span></code></pre></div><p>例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">page_id</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">user_id</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> title </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> url </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello-world.html</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">history</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pushState</span><span style="color:#A6ACCD;">(state</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> title</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> url)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">popstate</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// e.state 就是 pushState(stateObject) 中的 stateObject</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>两种模式的差异：</p><ul><li><p><code>Hash</code> 模式只能修改 <code>#</code> 后的内容，<code>History</code> 模式可以通过 <code>API</code> 设置任意同源 <code>URL</code></p></li><li><p><code>Hash</code> 模式只能改 <code>#</code> 后的哈希值，<code>History</code> 模式可以添加任意类型数据到历史数据中</p></li><li><p><code>Hash</code> 模式无需后端配置，兼容性好，<code>History</code> 模式在手动输入地址或刷新页面时会发起 <code>URL</code> 请求，后端需要支持配置 <code>index.html</code> 访问。</p></li></ul><h2 id="react-和-vue-之间的区别" tabindex="-1">React 和 Vue 之间的区别 <a class="header-anchor" href="#react-和-vue-之间的区别" aria-hidden="true">#</a></h2><p><code>Vue</code> 双向数据绑定，内部实现了数据的更新，修改数据相对 <code>React</code> 要简单，不用向 <code>React</code> 使用 <code>setState</code> 来改变状态。<code>React</code> 需要手动优化部分操作，而 <code>Vue</code> 的依赖追踪，页面渲染已内部最优。</p><p><code>React</code> 的 <code>JSX</code>，存在上手成本，更加灵活，选择周边工具完全需要靠用户自身对技术的把控。</p>`,48),t=[c];function r(D,d,y,i,F,C){return n(),a("div",null,t)}const u=s(e,[["render",r]]);export{h as __pageData,u as default};
