import{_ as s,c as a,o as n,a as o}from"./app.7a5de996.js";const l="/docs/imgs/mvc.png",e="/docs/imgs/mvvm.png",h=JSON.parse('{"title":"框架与框架","description":"","frontmatter":{},"headers":[],"relativePath":"guide/04_FRONTEND/00_框架与框架.md","lastUpdated":1670917237000}'),p={name:"guide/04_FRONTEND/00_框架与框架.md"},c=o('<h1 id="框架与框架" tabindex="-1">框架与框架 <a class="header-anchor" href="#框架与框架" aria-hidden="true">#</a></h1><h2 id="mvvm" tabindex="-1">MVVM <a class="header-anchor" href="#mvvm" aria-hidden="true">#</a></h2><ul><li><p>View：用户视图</p></li><li><p>Model：数据</p></li></ul><p>传统的 <code>MVC</code> 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新</p><p><img src="'+l+'" alt="mvc"></p><p>但是 <code>MVC</code> 有一个巨大的缺陷，<strong>控制器承担的责任太大</strong>。随着项目愈加的复杂，控制器中的代码也会越臃肿，导致不利于维护。</p><p>所以引入 <code>MVVM</code> 模式。添加了 <code>ViewModel</code> 概念。 <code>ViewModel</code> 只关心数据和业务的处理，不关心 <code>View</code> 如何处理数据，在这种情况下， <code>View</code> 和 <code>Model</code> 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可以复用的逻辑放在一个 <code>ViewModel</code> 中，让多个 <code>View</code> 复用这个 <code>ViewModel。</code></p><p><img src="'+e+`" alt="mvvm"></p><p>以 <code>Vue</code> 来举例，<code>ViewModel</code> 就是组件的实例。<code>View</code> 就是模板，<code>Model</code> 引入 <code>Vuex</code> 的情况下完全可以和组件分离。</p><p>对于 <code>MVVM</code> 来说，其实最重要的并不是通过双向绑定或者其他的方式将 <code>View</code> 与<code> ViewModel</code> 绑定起来，而是通过 <code>ViewModel</code> 将视图中的状态和用户的行为分离出一个抽象，这才是 <code>MVVM</code> 的精髓。</p><h2 id="virtual-dom" tabindex="-1">Virtual DOM <a class="header-anchor" href="#virtual-dom" aria-hidden="true">#</a></h2><p>由于直接操作 DOM 会存在性能缺陷，操作 JS 对象会快很多，所以通过 JS 来模拟 DOM</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ul </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">tag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ul</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">props</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">class</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">list</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">tag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">li</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>对应真实的 DOM 结构</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">list</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>可以通过 JS 对象渲染出对应的 DOM，但是如何判断新旧两个 JS 对象的<strong>最小差异</strong>且实现<strong>局部更新</strong> DOM。</p><p>TODO：待更新</p><h2 id="前端路由是如何跳转的" tabindex="-1">前端路由是如何跳转的 <a class="header-anchor" href="#前端路由是如何跳转的" aria-hidden="true">#</a></h2><h2 id="react-和-vue-之间的区别" tabindex="-1">React 和 Vue 之间的区别 <a class="header-anchor" href="#react-和-vue-之间的区别" aria-hidden="true">#</a></h2>`,19),t=[c];function r(d,D,i,F,y,C){return n(),a("div",null,t)}const A=s(p,[["render",r]]);export{h as __pageData,A as default};
